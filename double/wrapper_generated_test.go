// Code generated by double/internal/generator DO NOT EDIT.

package double

import (
	"testing"

	"github.com/krostar/test"

	"github.com/krostar/cli"
)

func Test_reduceWrapped(t *testing.T) {
	allInterfaces := []string{
		"CommandContext",
		"CommandDescription",
		"CommandExamples",
		"CommandFlags",
		"CommandHook",
		"CommandPersistentFlags",
		"CommandPersistentHook",
		"CommandUsage",
	}

	combinationsCount := 1 << len(allInterfaces)
	combinations := make([][]bool, combinationsCount)
	{ // build all possible combinations of interface implementations
		interfacesCount := len(allInterfaces)

		for i := range combinationsCount {
			comb := make([]bool, interfacesCount)
			for j := range interfacesCount {
				comb[j] = (i & (1 << j)) != 0
			}
			combinations[i] = comb
		}
	}

	checkInterfaceImplements := map[string]func(*testing.T, cli.Command) bool{
		"CommandContext": func(t *testing.T, cmd cli.Command) bool {
			_, ok := cmd.(cli.CommandContext)
			return ok
		},
		"CommandDescription": func(t *testing.T, cmd cli.Command) bool {
			_, ok := cmd.(cli.CommandDescription)
			return ok
		},
		"CommandExamples": func(t *testing.T, cmd cli.Command) bool {
			_, ok := cmd.(cli.CommandExamples)
			return ok
		},
		"CommandFlags": func(t *testing.T, cmd cli.Command) bool {
			_, ok := cmd.(cli.CommandFlags)
			return ok
		},
		"CommandHook": func(t *testing.T, cmd cli.Command) bool {
			_, ok := cmd.(cli.CommandHook)
			return ok
		},
		"CommandPersistentFlags": func(t *testing.T, cmd cli.Command) bool {
			_, ok := cmd.(cli.CommandPersistentFlags)
			return ok
		},
		"CommandPersistentHook": func(t *testing.T, cmd cli.Command) bool {
			_, ok := cmd.(cli.CommandPersistentHook)
			return ok
		},
		"CommandUsage": func(t *testing.T, cmd cli.Command) bool {
			_, ok := cmd.(cli.CommandUsage)
			return ok
		},
	}

	fake := new(fakeAllInterfaces)

	for i := 0; i < len(combinations); i++ {
		cmd := reduceWrapped(fake,
			combinations[i][0],
			combinations[i][1],
			combinations[i][2],
			combinations[i][3],
			combinations[i][4],
			combinations[i][5],
			combinations[i][6],
			combinations[i][7],
		)

		for j, shouldImplement := range combinations[i] {
			implements := checkInterfaceImplements[allInterfaces[j]](t, cmd)
			test.Assert(t, implements == shouldImplement, "%s implemented/should be: %t/%t", allInterfaces[j], implements, shouldImplement)
		}
	}
}
