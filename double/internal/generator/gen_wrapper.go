package main

import (
	"context"
	"fmt"
	"go/types"
	"maps"
	"os"
	"os/exec"
	"slices"
	"strings"
	"text/template"
)

type templateWrapperData struct {
	Imports       []string
	AllInterfaces []string
	Switch        templateWrapperDataSwitch
	Types         []templateWrapperDataType
}

type templateWrapperDataSwitch struct {
	Interfaces map[string]string
	Cases      []templateWrapperDataSwitchCase
}

type templateWrapperDataSwitchCase struct {
	Condition  string
	ReturnImpl string
}

type templateWrapperDataType struct {
	Name       string
	Interfaces []string
	Methods    []templateWrapperDataTypeMethod
}

type templateWrapperDataTypeMethod struct {
	ReceiverName string
	Name         string
	Inputs       string
	Outputs      string
	ReturnParams string
}

func generateInterfaceWrappedImplementation(ctx context.Context, mainCommandInterface *types.Interface, otherCommandInterfaces map[string]*types.Interface, destFilePath string) error {
	mainCommandName := "Command"
	tmpl := template.Must(template.New("wrapper").Funcs(template.FuncMap{
		"mapvalues": func(m map[string]string) []string {
			var values []string
			for _, value := range m {
				values = append(values, value)
			}
			slices.Sort(values)
			return values
		},
		"strjoin": strings.Join,
	}).Parse(`// Code generated by double/internal/generator DO NOT EDIT.

package double

import (
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

// commandAllInterfaces is a composite interface that includes all CLI command interfaces.
type commandAllInterfaces interface {
{{ range .AllInterfaces}}	{{ . }}
{{ end -}}
}

// reduceWrappedToUnderlyingInterface examines which interfaces the underlying command
// implements and returns a wrapper that implements the same interfaces.
// This ensures that the resulting wrapper preserves the exact interface set
// of the original command.
func reduceWrappedToUnderlyingInterface(underlying cli.Command, wrapped commandAllInterfaces) cli.Command {
	var (
		{{- range $name, $interface := .Switch.Interfaces }}
		_, {{ $interface }} = underlying.(cli.{{ $name }})
		{{- end }}
	)

	return reduceWrapped(wrapped, {{ strjoin (mapvalues .Switch.Interfaces) ", " }})
}

// reduceWrapped returns a command implementation that exposes only the specified interfaces.
func reduceWrapped(wrapped commandAllInterfaces, {{ strjoin (mapvalues .Switch.Interfaces) ", " }} bool) cli.Command {
	switch {
	{{- range .Switch.Cases}}
	case {{.Condition}}:
		return &{{ .ReturnImpl }}{ wrapped: wrapped }
	{{- end }}
	default:
		panic("this should never happen")
	}
}
{{ range $type := .Types }}
type {{ $type.Name }} struct { wrapped commandAllInterfaces }
{{ range $idx, $method := .Methods }}
func ({{ $method.ReceiverName }} *{{ $type.Name }}) {{ $method.Name }}{{ $method.Inputs }} {{ $method.Outputs }} { {{- if $method.Outputs }} return {{ $method.ReceiverName }}.wrapped.{{ $method.Name }}({{ $method.ReturnParams }}) {{- end }} } {{ end }}
{{ end }}`))

	var data templateWrapperData

	otherCommandInterfaceNames := slices.Sorted(maps.Keys(otherCommandInterfaces))
	otherCommandInterfaceNamesComb := generateCombinations(otherCommandInterfaceNames)

	allInterfaces := maps.Clone(otherCommandInterfaces)
	allInterfaces[mainCommandName] = mainCommandInterface

	for name := range allInterfaces {
		data.AllInterfaces = append(data.AllInterfaces, "cli."+name)
	}

	slices.Sort(data.AllInterfaces)

	{ // generate the create impl func
		conditionsToClone := make(map[string]bool, len(otherCommandInterfaceNames))
		data.Switch.Interfaces = make(map[string]string, len(otherCommandInterfaceNames))

		for _, name := range otherCommandInterfaceNames {
			conditionsToClone[name] = false
			data.Switch.Interfaces[name] = "ok" + name
		}

		for _, combinations := range append(otherCommandInterfaceNamesComb, []string{}) {
			conditions := maps.Clone(conditionsToClone)
			for _, iface := range combinations {
				conditions[iface] = true
			}

			var rawSwitchConditions []string

			for name, cond := range conditions {
				if cond {
					rawSwitchConditions = append(rawSwitchConditions, data.Switch.Interfaces[name])
				} else {
					rawSwitchConditions = append(rawSwitchConditions, "!"+data.Switch.Interfaces[name])
				}
			}

			data.Switch.Cases = append(data.Switch.Cases, templateWrapperDataSwitchCase{
				Condition:  strings.Join(rawSwitchConditions, " && "),
				ReturnImpl: "wrappedCommand" + strings.Join(combinations, ""),
			})
		}
	}

	{ // generate the types
		imports := make(map[string]string)

		for _, comb := range append([][]string{{}}, otherCommandInterfaceNamesComb...) {
			var (
				ifaces  []string
				methods []templateWrapperDataTypeMethod
			)

			for _, iface := range append([]string{mainCommandName}, comb...) {
				ifaces = append(ifaces, "cli."+iface)
				for method := range allInterfaces[iface].Methods() {
					sig := method.Signature()

					inputVars, _, inputVarsTypes := getTupleRepresentation(sig.Params(), imports, 0)
					_, outputTypes, _ := getTupleRepresentation(sig.Results(), imports, len(inputVars))

					methods = append(methods, templateWrapperDataTypeMethod{
						ReceiverName: "r",
						Name:         method.Name(),
						Inputs:       "(" + strings.Join(inputVarsTypes, ", ") + ")",
						Outputs:      strings.Join(outputTypes, ","),
						ReturnParams: strings.Join(inputVars, ", "),
					})
				}
			}

			data.Imports = slices.Sorted(maps.Keys(imports))
			data.Types = append(data.Types, templateWrapperDataType{
				Name:       "wrappedCommand" + strings.Join(comb, ""),
				Interfaces: ifaces,
				Methods:    methods,
			})
		}
	}

	file, err := os.Create(destFilePath)
	if err != nil {
		return fmt.Errorf("unable to open output file: %w", err)
	}
	defer file.Close()

	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("unable to execute template: %w", err)
	}

	if err := exec.CommandContext(ctx, "just", "fmt", destFilePath).Run(); err != nil {
		return fmt.Errorf("unable to format output: %w", err)
	}

	return nil
}

type templateTestWrapperData struct {
	Imports       []string
	AllInterfaces []string
}

func generateInterfaceWrappedTestImplementation(ctx context.Context, _ *types.Interface, otherCommandInterfaces map[string]*types.Interface, destFilePath string) error {
	tmpl := template.Must(template.New("wrapper").Parse(`// Code generated by double/internal/generator DO NOT EDIT.

package double

import (
	"testing"

	"github.com/krostar/cli"
	"github.com/krostar/test"
)

func Test_reduceWrapped(t *testing.T) {
	allInterfaces := []string{
		{{ range .AllInterfaces -}} "{{ . }}",
		{{ end -}}
	}

	combinationsCount := 1 << len(allInterfaces)
	combinations := make([][]bool, combinationsCount)
	{ // build all possible combinations of interface implementations
		interfacesCount := len(allInterfaces)

		for i := range combinationsCount {
			comb := make([]bool, interfacesCount)
			for j := range interfacesCount {
				comb[j] = (i & (1 << j)) != 0
			}
			combinations[i] = comb
		}
	}

	checkInterfaceImplements := map[string]func(*testing.T, cli.Command) bool{
	{{- range .AllInterfaces }}
		"{{ . }}": func(t *testing.T, cmd cli.Command) bool {
			_, ok := cmd.(cli.{{ . }})
			return ok
		},
	{{- end }}
	}

	fake := new(fakeAllInterfaces)

	for i := 0; i < len(combinations); i++ {
		cmd := reduceWrapped(fake,
		{{- range $idx, $name := .AllInterfaces }}
			combinations[i][{{ $idx }}],
		{{- end }}
		)

		for j, shouldImplement := range combinations[i] {
			implements := checkInterfaceImplements[allInterfaces[j]](t, cmd)
			test.Assert(t, implements == shouldImplement, "%s implemented/should be: %t/%t", allInterfaces[j], implements, shouldImplement)
		}
	}
}
`))

	var data templateTestWrapperData
	for name := range otherCommandInterfaces {
		data.AllInterfaces = append(data.AllInterfaces, name)
	}

	slices.Sort(data.AllInterfaces)

	file, err := os.Create(destFilePath)
	if err != nil {
		return fmt.Errorf("unable to open output file: %w", err)
	}
	defer file.Close()

	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("unable to execute template: %w", err)
	}

	if err := exec.CommandContext(ctx, "just", "fmt", destFilePath).Run(); err != nil {
		return fmt.Errorf("unable to format output: %w", err)
	}

	return nil
}
