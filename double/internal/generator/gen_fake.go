package main

import (
	"context"
	"fmt"
	"go/types"
	"maps"
	"os"
	"os/exec"
	"slices"
	"strings"
	"text/template"
)

type templateFakeData struct {
	Imports       []string
	ReduceMethods []string
	Methods       map[string]templateFakeDataMethod
}

type templateFakeDataMethod struct {
	Attribute      string
	InputVars      []string
	InputTypes     []string
	InputVarsTypes []string
	OutputTypes    []string
}

func generateFakeImplementation(ctx context.Context, mainCommand *types.Interface, otherCommandInterfaces map[string]*types.Interface, destFilePath string) error {
	mainCommandName := "Command"
	tmpl := template.Must(template.New("spy").Funcs(template.FuncMap{
		"strjoin": strings.Join,
	}).Parse(`// Code generated by double/internal/generator DO NOT EDIT.

package double

import (
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

// NewFake creates a new fake implementation of the cli.Command interface.
//
// By default, the fake command only implements the basic Execute method,
// returning nil. Use the FakeWith* options to implement additional interfaces
// and customize behavior.
func NewFake(opts ...FakeOption) cli.Command {
	f := new(fakeAllInterfaces)
	f.onExecute = func(context.Context, []string, []string) error { return nil }

	for _, opt := range opts {
		opt(f)
	}

	return reduceWrapped(f,
		{{- range $idx, $method := .ReduceMethods }}
		f.{{ $method }} != nil,
		{{- end }}
	)
}

// FakeOption is a function to configures a fake behavior.
type FakeOption func(f *fakeAllInterfaces)
{{ range $name, $method := .Methods }}
// FakeWith{{ $name }} configures the fake to implement the {{ $name }} method.
// The provided function will be called when the {{ $name }} method is invoked.
func FakeWith{{ $name }}(f func({{ strjoin $method.InputTypes ", " }}){{ if gt (len $method.OutputTypes) 1 }} ({{- end }} {{ strjoin $method.OutputTypes ", " }}{{ if gt (len $method.OutputTypes) 1 -}} ) {{ end }}) FakeOption { return func(fake *fakeAllInterfaces) { fake.{{ $method.Attribute }} = f } }
{{- end }}

type fakeAllInterfaces struct {
{{- range $name, $method := .Methods }}
	{{ $method.Attribute }} func({{ strjoin $method.InputTypes ", " }}){{ if gt (len $method.OutputTypes) 1 }} ({{- end }} {{ strjoin $method.OutputTypes ", " }}{{ if gt (len $method.OutputTypes) 1 -}} ) {{ end }}
{{- end }}
}
{{ range $name, $method := .Methods }}
func (fake *fakeAllInterfaces) {{ $name }}({{ strjoin $method.InputVarsTypes ", " }}){{ if gt (len $method.OutputTypes) 1 }} ({{- end }} {{ strjoin $method.OutputTypes ", " }}{{ if gt (len $method.OutputTypes) 1 -}} ){{ end }} {
	{{- if $method.OutputTypes }} return {{ end }}fake.on{{ $name }}({{ strjoin $method.InputVars ", " }}) }
{{ end }}`))

	var data templateFakeData

	allInterfaces := maps.Clone(otherCommandInterfaces)
	allInterfaces[mainCommandName] = mainCommand

	imports := make(map[string]string)
	imports["github.com/krostar/cli"] = "cli"

	data.Methods = make(map[string]templateFakeDataMethod)
	for ifaceName, iface := range allInterfaces {
		for method := range iface.Methods() {
			sig := method.Signature()

			inputVars, inputTypes, inputVarsTypes := getTupleRepresentation(sig.Params(), imports, 0)
			_, outputTypes, _ := getTupleRepresentation(sig.Results(), imports, len(inputVars))

			attribute := "on" + method.Name()

			if ifaceName != mainCommandName {
				data.ReduceMethods = append(data.ReduceMethods, attribute)
			}

			data.Methods[method.Name()] = templateFakeDataMethod{
				Attribute:      attribute,
				InputVars:      inputVars,
				InputTypes:     inputTypes,
				InputVarsTypes: inputVarsTypes,
				OutputTypes:    outputTypes,
			}
		}
	}

	slices.Sort(data.ReduceMethods)
	data.Imports = slices.Sorted(maps.Keys(imports))

	file, err := os.Create(destFilePath)
	if err != nil {
		return fmt.Errorf("unable to open output file: %w", err)
	}
	defer file.Close()

	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("unable to execute template: %w", err)
	}

	if err := exec.CommandContext(ctx, "just", "fmt", destFilePath).Run(); err != nil {
		return fmt.Errorf("unable to format output: %w", err)
	}

	return nil
}
