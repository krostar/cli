package main

import (
	"fmt"
	"go/types"
	"maps"
	"os"
	"os/exec"
	"slices"
	"strings"
	"text/template"
)

type templateSpyData struct {
	Imports []string
	Methods []templateSpyDataMethod
}

type templateSpyDataMethod struct {
	Name           string
	Implements     string
	InputVars      []string
	InputVarsTypes []string
	OutputVars     []string
	OutputTypes    []string
}

func generateSpyImplementation(mainCommandInterface *types.Interface, otherCommandInterfaces map[string]*types.Interface, destFilePath string) error {
	mainCommandName := "Command"
	tmpl := template.Must(template.New("spy").Funcs(template.FuncMap{
		"strjoin": strings.Join,
	}).Parse(`// Code generated by double/internal/generator DO NOT EDIT.

package double

import (
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

// spyAllInterfaces implements all CLI command interfaces while capturing method calls.
// It wraps an underlying command and intercepts all interface method calls to record them.
// This allows for testing which methods were called, with what parameters, and in what order.
type spyAllInterfaces struct {
	underlying cli.Command  // The actual command being spied on
	saveRecord func(record SpyCommandRecord)  // Function to save records of method calls
}
{{ range $idx, $method := .Methods }}
// {{ $method.Name }} implements the {{ $method.Implements }} interface.
// It forwards the call to the underlying command while recording the method call,
// its parameters, and the return values.
func (spy *spyAllInterfaces) {{ $method.Name }}({{ strjoin $method.InputVarsTypes ", " }}){{ if gt (len $method.OutputTypes) 1 }} ({{- end }} {{ strjoin $method.OutputTypes ", " }}{{ if gt (len $method.OutputTypes) 1 -}} ) {{- end }} {
	{{ if $method.OutputTypes -}}{{ strjoin $method.OutputVars ", " }} := {{ end -}}
	spy.underlying.({{ $method.Implements }}).{{ $method.Name }}({{ strjoin $method.InputVars ", " }})

	spy.saveRecord(SpyCommandRecord{
		Method:  "{{ $method.Name }}",
		Inputs:  []any{ {{- strjoin $method.InputVars ", " -}} },
		Outputs: []any{ {{- strjoin $method.OutputVars ", " -}} },
	})

	{{ if $method.OutputTypes -}}
	return {{ strjoin $method.OutputVars ", " }}
	{{- end }}
}
{{ end }}`))

	var data templateSpyData

	allInterfaces := maps.Clone(otherCommandInterfaces)
	allInterfaces[mainCommandName] = mainCommandInterface

	imports := make(map[string]string)
	imports["github.com/krostar/cli"] = "cli"

	for name, iface := range allInterfaces {
		for method := range iface.Methods() {
			sig := method.Signature()

			inputVars, _, inputVarsTypes := getTupleRepresentation(sig.Params(), imports, 0)
			outputVars, outputTypes, _ := getTupleRepresentation(sig.Results(), imports, len(inputVars))

			data.Methods = append(data.Methods, templateSpyDataMethod{
				Name:           method.Name(),
				Implements:     "cli." + name,
				InputVars:      inputVars,
				InputVarsTypes: inputVarsTypes,
				OutputVars:     outputVars,
				OutputTypes:    outputTypes,
			})
		}
	}

	data.Imports = slices.Sorted(maps.Keys(imports))

	file, err := os.Create(destFilePath)
	if err != nil {
		return fmt.Errorf("unable to open output file: %w", err)
	}
	defer file.Close()

	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("unable to execute template: %w", err)
	}

	if err := exec.Command("just", "fmt", destFilePath).Run(); err != nil {
		return fmt.Errorf("unable to format output: %w", err)
	}

	return nil
}
